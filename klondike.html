<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÊûÅÁÆÄÁ∫∏Áâå (Klondike)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --card-width: 60px;
            --card-height: 84px;
            --gap: 8px;
            --radius: 6px;
            --bg-light: #e6e6e6; /* Classic Green Table feel replaced with clean grey */
            --bg-dark: #1f2937;
            --card-back: #3b82f6;
            --text-light: #1f2937;
            --text-dark: #f3f4f6;
        }

        @media (min-width: 640px) {
            :root {
                --card-width: 80px;
                --card-height: 112px;
                --gap: 12px;
                --radius: 8px;
            }
        }

        @media (min-width: 1024px) {
            :root {
                --card-width: 100px;
                --card-height: 140px;
                --gap: 16px;
                --radius: 10px;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            transition: background-color 0.3s, color 0.3s;
            overflow: hidden; /* Prevent scrolling on mobile drag */
            touch-action: manipulation;
        }

        .theme-light { background-color: #f0fdf4; color: #166534; --placeholder: rgba(22, 101, 52, 0.1); --card-shadow: 0 2px 5px rgba(0,0,0,0.15); }
        .theme-dark { background-color: #111827; color: #e5e7eb; --placeholder: rgba(255, 255, 255, 0.1); --card-shadow: 0 4px 6px rgba(0,0,0,0.4); }

        /* Card Styles */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: var(--radius);
            background-color: white;
            position: absolute;
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 4px;
            box-sizing: border-box;
            user-select: none;
            cursor: pointer;
            transition: transform 0.1s;
            font-weight: bold;
            font-size: 1rem;
        }

        @media (min-width: 640px) { .card { font-size: 1.25rem; padding: 6px; } }
        @media (min-width: 1024px) { .card { font-size: 1.5rem; padding: 8px; } }

        .card.red { color: #ef4444; }
        .card.black { color: #1f2937; }
        
        .card-face-down {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            border: 2px solid white;
        }
        
        .card-face-down::after {
            content: '';
            position: absolute;
            inset: 4px;
            border: 1px dashed rgba(255,255,255,0.3);
            border-radius: calc(var(--radius) - 2px);
        }

        .card.selected {
            transform: translateY(-10px);
            box-shadow: 0 0 0 3px #fbbf24, 0 10px 15px rgba(0,0,0,0.2);
            z-index: 100 !important;
        }

        .card.hint-highlight {
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Slot Styles */
        .slot {
            width: var(--card-width);
            height: var(--card-height);
            border-radius: var(--radius);
            border: 2px dashed var(--placeholder);
            position: relative;
        }

        .pile-container {
            position: relative;
            width: var(--card-width);
            height: var(--card-height);
        }

        /* Layout Grid */
        .game-board {
            display: grid;
            grid-template-columns: repeat(7, var(--card-width));
            gap: var(--gap);
            justify-content: center;
            padding-top: 20px;
        }

        /* Icons */
        .suit-icon { width: 1em; height: 1em; fill: currentColor; }
        .center-suit {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            opacity: 0.2;
        }

        /* Utility */
        .hidden { display: none; }
        
        /* Modal */
        .modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.5);
            display: flex; justify-content: center; align-items: center; z-index: 50;
        }
    </style>
</head>
<body class="theme-light h-screen flex flex-col">

    <!-- Header / Controls -->
    <header class="flex justify-between items-center p-4 shadow-sm z-10 shrink-0">
        <div class="flex items-center gap-4">
            <h1 class="text-xl font-bold hidden sm:block">Á∫∏ÁâåÊé•Èæô</h1>
            <div class="flex flex-col sm:flex-row gap-1 sm:gap-4 text-sm font-mono">
                <span>ÂàÜÊï∞: <span id="score">0</span></span>
                <span>Ê≠•Êï∞: <span id="moves">0</span></span>
            </div>
        </div>
        <div class="flex gap-2">
            <button onclick="game.toggleTheme()" class="p-2 rounded hover:bg-black/10 dark:hover:bg-white/10" title="ÂàáÊç¢‰∏ªÈ¢ò">
                <svg id="icon-theme" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </button>
            <button onclick="game.undo()" class="p-2 rounded hover:bg-black/10 dark:hover:bg-white/10" title="Êí§ÈîÄ">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>
            </button>
            <button onclick="game.showHint()" class="p-2 rounded hover:bg-black/10 dark:hover:bg-white/10" title="ÊèêÁ§∫">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
            </button>
            <button onclick="game.newGameConfirm()" class="px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm font-bold">Êñ∞Ê∏∏Êàè</button>
        </div>
    </header>

    <!-- Game Area -->
    <main class="flex-grow relative overflow-auto select-none p-4 flex flex-col items-center">
        
        <!-- Top Row: Stock, Waste, Foundations -->
        <div class="game-board mb-8">
            <!-- Stock -->
            <div id="stock-slot" class="slot cursor-pointer" onclick="game.drawCard()"></div>
            <!-- Waste -->
            <div id="waste-slot" class="slot"></div>
            <!-- Spacer (2 cols width visual adjustment handled by grid) -->
            <div></div> 
            
            <!-- Foundations -->
            <div id="fnd-0" class="slot" data-type="foundation" data-id="0" onclick="game.clickSlot('foundation', 0)"></div>
            <div id="fnd-1" class="slot" data-type="foundation" data-id="1" onclick="game.clickSlot('foundation', 1)"></div>
            <div id="fnd-2" class="slot" data-type="foundation" data-id="2" onclick="game.clickSlot('foundation', 2)"></div>
            <div id="fnd-3" class="slot" data-type="foundation" data-id="3" onclick="game.clickSlot('foundation', 3)"></div>
        </div>

        <!-- Bottom Row: Tableau -->
        <div class="game-board">
            <div id="tab-0" class="pile-container" data-type="tableau" data-id="0" onclick="game.clickSlot('tableau', 0)"></div>
            <div id="tab-1" class="pile-container" data-type="tableau" data-id="1" onclick="game.clickSlot('tableau', 1)"></div>
            <div id="tab-2" class="pile-container" data-type="tableau" data-id="2" onclick="game.clickSlot('tableau', 2)"></div>
            <div id="tab-3" class="pile-container" data-type="tableau" data-id="3" onclick="game.clickSlot('tableau', 3)"></div>
            <div id="tab-4" class="pile-container" data-type="tableau" data-id="4" onclick="game.clickSlot('tableau', 4)"></div>
            <div id="tab-5" class="pile-container" data-type="tableau" data-id="5" onclick="game.clickSlot('tableau', 5)"></div>
            <div id="tab-6" class="pile-container" data-type="tableau" data-id="6" onclick="game.clickSlot('tableau', 6)"></div>
        </div>

    </main>

    <!-- Win Modal -->
    <div id="win-modal" class="modal hidden">
        <div class="bg-white dark:bg-gray-800 p-8 rounded-xl shadow-2xl text-center transform transition-all scale-100">
            <h2 class="text-3xl font-bold mb-4 text-yellow-500">ÊÅ≠ÂñúËÉúÂà©! üéâ</h2>
            <p class="mb-6 text-gray-600 dark:text-gray-300">‰Ω†Ê∏ÖÁ©∫‰∫ÜÊâÄÊúâÁ∫∏Áâå„ÄÇ</p>
            <button onclick="game.init()" class="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 font-bold shadow-lg">ÂÜçÊù•‰∏ÄÂ±Ä</button>
        </div>
    </div>

    <script>
        /**
         * Game Logic
         */
        const SUITS = ['hearts', 'diamonds', 'clubs', 'spades'];
        const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const COLORS = { hearts: 'red', diamonds: 'red', clubs: 'black', spades: 'black' };
        const SYMBOLS = { 
            hearts: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>',
            diamonds: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 12l10 10 10-10L12 2z"/></svg>',
            clubs: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9 2 7 3.79 7 6c0 1.15.47 2.22 1.25 3-.78.78-1.25 1.85-1.25 3 0 2.21 2 4 5 4s5-1.79 5-4c0-1.15-.47-2.22-1.25-3 .78-.78 1.25-1.85 1.25-3 0-2.21-2-4-5-4zm0 13c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z" transform="translate(0 -2) scale(1 0.9)"/></svg>', // Approximate club shape
            spades: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C9 2 7 3.79 7 6c0 1.15.47 2.22 1.25 3-.78.78-1.25 1.85-1.25 3 0 2.21 2 4 5 4s5-1.79 5-4c0-1.15-.47-2.22-1.25-3 .78-.78 1.25-1.85 1.25-3 0-2.21-2-4-5-4zm0 13c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z" transform="rotate(180 12 12) translate(0 -2) scale(1 0.9)"/></svg>' // Inverted club approx as spade base
        };
        // Better Spades/Clubs paths for clarity
        SYMBOLS.spades = '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12,2C8,2,2,8,2,12c0,3,3,6,6,6l1,4h6l1-4c3,0,6-3,6-6C22,8,16,2,12,2z" style="display:none"/><path d="M12 2.5c-3 4-8 8-8 12.5 0 2.5 2 4.5 4.5 4.5 1.5 0 2.5-1 3.5-2.5 1 1.5 2 2.5 3.5 2.5 2.5 0 4.5-2 4.5-4.5C20 10.5 15 6.5 12 2.5z M12 21.5l-1 2h2l-1-2z"/></svg>';
        SYMBOLS.clubs = '<svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="7" r="4.5"/><circle cx="7" cy="15" r="4.5"/><circle cx="17" cy="15" r="4.5"/><path d="M12 14l-1.5 8h3L12 14z"/></svg>';


        class Klondike {
            constructor() {
                this.state = {
                    stock: [],
                    waste: [],
                    foundations: [[], [], [], []],
                    tableau: [[], [], [], [], [], [], []],
                    score: 0,
                    moves: 0
                };
                this.history = [];
                this.selected = null; // { type: 'waste'|'tableau', index: int, cardIndex: int }
                
                this.initTheme();
                this.loadState() || this.init();
            }

            initTheme() {
                const isDark = localStorage.getItem('klondikeTheme') === 'dark' || 
                             (!localStorage.getItem('klondikeTheme') && window.matchMedia('(prefers-color-scheme: dark)').matches);
                if (isDark) document.body.classList.replace('theme-light', 'theme-dark');
                this.updateThemeIcon();
            }

            toggleTheme() {
                const body = document.body;
                if (body.classList.contains('theme-light')) {
                    body.classList.replace('theme-light', 'theme-dark');
                    localStorage.setItem('klondikeTheme', 'dark');
                } else {
                    body.classList.replace('theme-dark', 'theme-light');
                    localStorage.setItem('klondikeTheme', 'light');
                }
                this.updateThemeIcon();
            }

            updateThemeIcon() {
                const isDark = document.body.classList.contains('theme-dark');
                const icon = document.getElementById('icon-theme');
                if (isDark) {
                    // Sun icon
                    icon.innerHTML = '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>';
                } else {
                    // Moon icon
                    icon.innerHTML = '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>';
                }
            }

            createDeck() {
                let deck = [];
                for (let suit of SUITS) {
                    for (let i = 0; i < RANKS.length; i++) {
                        deck.push({ 
                            suit, 
                            rank: i + 1, // 1=A, 13=K
                            rankChar: RANKS[i],
                            color: COLORS[suit],
                            faceUp: false,
                            id: Math.random().toString(36).substr(2, 9)
                        });
                    }
                }
                // Fisher-Yates Shuffle
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                return deck;
            }

            init() {
                const deck = this.createDeck();
                this.state = {
                    stock: [],
                    waste: [],
                    foundations: [[], [], [], []],
                    tableau: [[], [], [], [], [], [], []],
                    score: 0,
                    moves: 0
                };
                this.history = [];
                this.selected = null;

                // Deal
                let cardIdx = 0;
                for (let i = 0; i < 7; i++) {
                    for (let j = 0; j <= i; j++) {
                        let card = deck[cardIdx++];
                        if (j === i) card.faceUp = true;
                        this.state.tableau[i].push(card);
                    }
                }
                this.state.stock = deck.slice(cardIdx);
                
                document.getElementById('win-modal').classList.add('hidden');
                this.render();
                this.saveState();
            }

            newGameConfirm() {
                if(confirm('Á°ÆÂÆöË¶ÅÂºÄÂßãÊñ∞Ê∏∏ÊàèÂêóÔºüÂΩìÂâçËøõÂ∫¶Â∞Ü‰∏¢Â§±„ÄÇ')) {
                    this.init();
                }
            }

            saveState() {
                localStorage.setItem('klondikeState', JSON.stringify({
                    state: this.state,
                    history: this.history
                }));
            }

            loadState() {
                const saved = localStorage.getItem('klondikeState');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        this.state = parsed.state;
                        this.history = parsed.history;
                        this.render();
                        return true;
                    } catch (e) {
                        console.error("Save file corrupted");
                        return false;
                    }
                }
                return false;
            }

            pushHistory() {
                // Deep copy state
                const stateCopy = JSON.parse(JSON.stringify(this.state));
                this.history.push(stateCopy);
                // Limit history size if needed, but modern browsers handle large arrays fine
            }

            undo() {
                if (this.history.length === 0) return;
                this.state = this.history.pop();
                this.selected = null;
                this.render();
                this.saveState();
            }

            getCardHtml(card, onClickFn, extraClass = '') {
                if (!card) return '';
                if (!card.faceUp) {
                    return `<div class="card card-face-down ${extraClass}" onclick="${onClickFn}"></div>`;
                }
                return `
                    <div class="card ${card.color} ${extraClass}" onclick="${onClickFn}" id="${card.id}">
                        <div class="flex flex-col items-center leading-none">
                            <span>${card.rankChar}</span>
                            <div class="suit-icon w-3 h-3">${SYMBOLS[card.suit]}</div>
                        </div>
                        <div class="center-suit">${SYMBOLS[card.suit]}</div>
                        <div class="flex flex-col items-center leading-none rotate-180">
                            <span>${card.rankChar}</span>
                            <div class="suit-icon w-3 h-3">${SYMBOLS[card.suit]}</div>
                        </div>
                    </div>
                `;
            }

            render() {
                // Score & Moves
                document.getElementById('score').textContent = this.state.score;
                document.getElementById('moves').textContent = this.state.moves;

                // Stock
                const stockEl = document.getElementById('stock-slot');
                if (this.state.stock.length > 0) {
                    stockEl.innerHTML = `<div class="card card-face-down">
                        <div class="absolute inset-0 flex items-center justify-center text-white font-bold opacity-50 text-xl">${this.state.stock.length}</div>
                    </div>`;
                } else {
                    stockEl.innerHTML = `<div class="w-full h-full border-2 border-dashed border-gray-400 rounded-lg flex items-center justify-center opacity-30 text-2xl">‚Ü∫</div>`;
                }

                // Waste
                const wasteEl = document.getElementById('waste-slot');
                wasteEl.innerHTML = '';
                if (this.state.waste.length > 0) {
                    const topCard = this.state.waste[this.state.waste.length - 1];
                    const isSelected = this.isSelected('waste', 0, this.state.waste.length - 1);
                    wasteEl.innerHTML = this.getCardHtml(topCard, `event.stopPropagation(); game.cardClick('waste', 0, ${this.state.waste.length - 1})`, isSelected ? 'selected' : '');
                }

                // Foundations
                this.state.foundations.forEach((pile, i) => {
                    const el = document.getElementById(`fnd-${i}`);
                    el.innerHTML = '';
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        el.innerHTML = this.getCardHtml(topCard, `event.stopPropagation(); game.clickSlot('foundation', ${i})`);
                    } else {
                        // Empty placeholder icon
                        el.innerHTML = `<div class="absolute inset-0 flex items-center justify-center text-3xl opacity-20 text-gray-500 font-bold">A</div>`;
                    }
                });

                // Tableau
                this.state.tableau.forEach((pile, i) => {
                    const el = document.getElementById(`tab-${i}`);
                    el.innerHTML = '';
                    // Render pile
                    pile.forEach((card, cardIdx) => {
                        const offset = cardIdx * (window.innerWidth < 640 ? 25 : 35); // Vertical spacing
                        const isSelected = this.isSelected('tableau', i, cardIdx);
                        const cardHtml = this.getCardHtml(card, `event.stopPropagation(); game.cardClick('tableau', ${i}, ${cardIdx})`, isSelected ? 'selected' : '');
                        
                        // Wrap in positioning div
                        const wrapper = document.createElement('div');
                        wrapper.style.position = 'absolute';
                        wrapper.style.top = `${offset}px`;
                        wrapper.style.zIndex = cardIdx;
                        wrapper.innerHTML = cardHtml;
                        el.appendChild(wrapper);
                    });
                    
                    // Add an invisible click area at the bottom/empty slot to catch drops
                    if (pile.length === 0) {
                        el.style.height = 'var(--card-height)';
                    } else {
                        const height = (pile.length - 1) * (window.innerWidth < 640 ? 25 : 35) + parseInt(getComputedStyle(document.documentElement).getPropertyValue('--card-height'));
                        el.style.height = `${height}px`;
                    }
                });
                
                this.checkWin();
            }

            isSelected(type, idx, cardIdx) {
                return this.selected && this.selected.type === type && this.selected.index === idx && this.selected.cardIndex === cardIdx;
            }

            drawCard() {
                this.pushHistory();
                this.selected = null;
                
                if (this.state.stock.length === 0) {
                    // Reset stock from waste
                    if (this.state.waste.length > 0) {
                        this.state.stock = this.state.waste.reverse().map(c => ({...c, faceUp: false}));
                        this.state.waste = [];
                        this.state.moves++;
                    }
                } else {
                    // Draw
                    const card = this.state.stock.pop();
                    card.faceUp = true;
                    this.state.waste.push(card);
                    this.state.moves++;
                }
                this.render();
                this.saveState();
            }

            cardClick(type, pileIdx, cardIdx) {
                // Double click handling
                const now = new Date().getTime();
                if (this.lastClick && (now - this.lastClick < 300) && this.lastClickCard === `${type}-${pileIdx}-${cardIdx}`) {
                    this.tryAutoMove(type, pileIdx, cardIdx);
                    this.lastClick = 0;
                    return;
                }
                this.lastClick = now;
                this.lastClickCard = `${type}-${pileIdx}-${cardIdx}`;

                const pile = type === 'waste' ? this.state.waste : this.state.tableau[pileIdx];
                const card = pile[cardIdx];

                // Logic:
                // 1. If nothing selected, select this card (must be face up)
                // 2. If something selected:
                //    a. If clicking same card, deselect
                //    b. If clicking another card, try to move selected TO this card
                
                if (!card.faceUp) {
                    // Can't select face down, but if it's the top face down card, we might flip it? 
                    // No, Klondike flips automatically. 
                    // Actually, if we click a valid destination (empty slot) handled by clickSlot.
                    return;
                }

                if (!this.selected) {
                    // Select
                    this.selected = { type, index: pileIdx, cardIndex: cardIdx };
                    this.render(); // Update selection visual
                } else {
                    // Action
                    if (this.selected.type === type && this.selected.index === pileIdx && this.selected.cardIndex === cardIdx) {
                        // Deselect
                        this.selected = null;
                        this.render();
                    } else {
                        // Try move to this card
                        this.attemptMove(this.selected, { type, index: pileIdx });
                    }
                }
            }

            clickSlot(type, idx) {
                // Handle clicking on empty slots or foundation slots
                if (this.selected) {
                    this.attemptMove(this.selected, { type, index: idx });
                }
            }

            attemptMove(from, to) {
                const fromPile = from.type === 'waste' ? this.state.waste : this.state.tableau[from.index];
                const cardsToMove = fromPile.slice(from.cardIndex);
                const movingCard = cardsToMove[0];

                let valid = false;

                if (to.type === 'tableau') {
                    const toPile = this.state.tableau[to.index];
                    if (toPile.length === 0) {
                        // King only
                        if (movingCard.rank === 13) valid = true;
                    } else {
                        const targetCard = toPile[toPile.length - 1];
                        if (targetCard.color !== movingCard.color && targetCard.rank === movingCard.rank + 1) {
                            valid = true;
                        }
                    }
                } else if (to.type === 'foundation') {
                    // Can only move 1 card at a time to foundation
                    if (cardsToMove.length === 1) {
                        const toPile = this.state.foundations[to.index];
                        if (toPile.length === 0) {
                            // Ace only
                            if (movingCard.rank === 1) valid = true;
                        } else {
                            const targetCard = toPile[toPile.length - 1];
                            if (targetCard.suit === movingCard.suit && targetCard.rank === movingCard.rank - 1) {
                                valid = true;
                            }
                        }
                    }
                }

                if (valid) {
                    this.executeMove(from, to, cardsToMove);
                } else {
                    // Invalid move feedback could go here (shake animation etc)
                    this.selected = null;
                    this.render();
                }
            }

            executeMove(from, to, cards) {
                this.pushHistory();

                // Remove from source
                if (from.type === 'waste') {
                    this.state.waste.pop();
                } else {
                    this.state.tableau[from.index].splice(from.cardIndex, cards.length);
                    // Flip new top card if face down
                    const tab = this.state.tableau[from.index];
                    if (tab.length > 0 && !tab[tab.length - 1].faceUp) {
                        tab[tab.length - 1].faceUp = true;
                        this.state.score += 5; 
                    }
                }

                // Add to dest
                if (to.type === 'tableau') {
                    this.state.tableau[to.index].push(...cards);
                } else {
                    this.state.foundations[to.index].push(cards[0]);
                    this.state.score += 10;
                }

                this.state.moves++;
                this.selected = null;
                this.render();
                this.saveState();
            }

            tryAutoMove(type, pileIdx, cardIdx) {
                // Logic: Check if card fits on any foundation
                const pile = type === 'waste' ? this.state.waste : this.state.tableau[pileIdx];
                // Can only auto move the top card
                if (cardIdx !== pile.length - 1) return;
                
                const card = pile[cardIdx];
                
                for (let i = 0; i < 4; i++) {
                    const f = this.state.foundations[i];
                    let valid = false;
                    if (f.length === 0 && card.rank === 1) valid = true;
                    else if (f.length > 0 && f[f.length-1].suit === card.suit && f[f.length-1].rank === card.rank - 1) valid = true;

                    if (valid) {
                        this.executeMove({type, index: pileIdx, cardIndex: cardIdx}, {type: 'foundation', index: i}, [card]);
                        return;
                    }
                }
            }
            
            checkWin() {
                const total = this.state.foundations.reduce((acc, p) => acc + p.length, 0);
                if (total === 52) {
                    document.getElementById('win-modal').classList.remove('hidden');
                }
            }

            showHint() {
                // Clear existing hints
                document.querySelectorAll('.hint-highlight').forEach(el => el.classList.remove('hint-highlight'));

                // Simple hint logic:
                // 1. Check Waste -> Foundation
                // 2. Check Tableau End -> Foundation
                // 3. Check Waste -> Tableau
                // 4. Check Tableau -> Tableau (that uncovers a card)

                let hintCardId = null;

                const checkFitFoundation = (card) => {
                    for(let f of this.state.foundations) {
                        if (f.length === 0 && card.rank === 1) return true;
                        if (f.length > 0 && f[f.length-1].suit === card.suit && f[f.length-1].rank === card.rank - 1) return true;
                    }
                    return false;
                };

                const checkFitTableau = (card) => {
                     for(let t of this.state.tableau) {
                         if (t.length === 0 && card.rank === 13) return true;
                         if (t.length > 0) {
                             const target = t[t.length-1];
                             if (target.color !== card.color && target.rank === card.rank + 1) return true;
                         }
                     }
                     return false;
                }

                // Waste top
                if (this.state.waste.length > 0) {
                    const c = this.state.waste[this.state.waste.length-1];
                    if (checkFitFoundation(c) || checkFitTableau(c)) {
                        hintCardId = c.id;
                    }
                }

                // Tableau
                if (!hintCardId) {
                    for (let i=0; i<7; i++) {
                        const pile = this.state.tableau[i];
                        if (pile.length === 0) continue;
                        
                        // Check top card to foundation
                        const top = pile[pile.length-1];
                        if (checkFitFoundation(top)) {
                            hintCardId = top.id;
                            break;
                        }

                        // Check movable stacks to other tableau
                        // Iterate from first face up card
                        const firstFaceUpIdx = pile.findIndex(c => c.faceUp);
                        if (firstFaceUpIdx === -1) continue;

                        // We prefer moves that uncover cards
                        if (firstFaceUpIdx > 0 || pile.length === 0) { // Should uncover something
                             // Optimization: Don't suggest moving King to empty spot if it's already at bottom
                             // But for simplicity, just check valid moves
                        }

                        for (let j=firstFaceUpIdx; j<pile.length; j++) {
                            const c = pile[j];
                            // Only useful if it's not a King on an empty spot already (avoid loop hints)
                            if (c.rank === 13 && firstFaceUpIdx === 0) continue; 
                            
                            if (checkFitTableau(c)) {
                                hintCardId = c.id;
                                break;
                            }
                        }
                        if (hintCardId) break;
                    }
                }
                
                // Stock fallback
                if (!hintCardId && this.state.stock.length > 0) {
                     const stockEl = document.getElementById('stock-slot');
                     stockEl.classList.add('hint-highlight');
                     setTimeout(() => stockEl.classList.remove('hint-highlight'), 1000);
                     return;
                }

                if (hintCardId) {
                    const el = document.getElementById(hintCardId);
                    if (el) {
                        el.classList.add('hint-highlight');
                        setTimeout(() => el.classList.remove('hint-highlight'), 1000);
                    }
                } else {
                    // No moves found alert or visual
                }
            }
        }

        // Initialize Game
        const game = new Klondike();

        // Global listeners for responsiveness
        window.addEventListener('resize', () => {
             game.render();
        });
    </script>
</body>
</html>